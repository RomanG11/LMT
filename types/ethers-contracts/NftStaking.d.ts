/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  CallOverrides
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface NftStakingInterface extends ethers.utils.Interface {
  functions: {
    "apyStruct(uint256)": FunctionFragment;
    "endRewardTime()": FunctionFragment;
    "feeReceiverAddress()": FunctionFragment;
    "getBlockNumber()": FunctionFragment;
    "higherTierCardsStaked(address,uint256)": FunctionFragment;
    "impl()": FunctionFragment;
    "isOwner()": FunctionFragment;
    "lastUpdateState()": FunctionFragment;
    "lastUserClaim(address)": FunctionFragment;
    "lowerTierCardsStaked(address,uint256)": FunctionFragment;
    "name()": FunctionFragment;
    "nft()": FunctionFragment;
    "owner()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "rewardSent()": FunctionFragment;
    "rewardToken()": FunctionFragment;
    "setImplementation(address)": FunctionFragment;
    "stakingToken()": FunctionFragment;
    "tokensStaked(address)": FunctionFragment;
    "totalHigherTierCardsPerUser()": FunctionFragment;
    "totalLowerTierCardsPerUser()": FunctionFragment;
    "totalPoolSize()": FunctionFragment;
    "totalReward()": FunctionFragment;
    "totalRewardPerSecond()": FunctionFragment;
    "totalStaked()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "unstakeFee()": FunctionFragment;
    "unstakeFeeDuration()": FunctionFragment;
    "userApy(address)": FunctionFragment;
    "userLastStakeTime(address)": FunctionFragment;
    "utils()": FunctionFragment;
    "getUserCardsStaked(address)": FunctionFragment;
    "getPoolData(address)": FunctionFragment;
    "getPoolData2(address)": FunctionFragment;
    "updateUsers(address[])": FunctionFragment;
    "update()": FunctionFragment;
    "updateUser(address)": FunctionFragment;
    "init(string,address,address,address,address,address)": FunctionFragment;
    "stakeCards(uint256[])": FunctionFragment;
    "withdraw(uint256[])": FunctionFragment;
    "getApyByStake(uint256)": FunctionFragment;
    "getApy(uint256[])": FunctionFragment;
    "getBoostedApy(address)": FunctionFragment;
    "getReward(address)": FunctionFragment;
    "getTotalApy(address)": FunctionFragment;
    "getUserRewardPerSecond(address)": FunctionFragment;
    "onERC1155Received(address,address,uint256,uint256,bytes)": FunctionFragment;
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "apyStruct",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "endRewardTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "feeReceiverAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBlockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "higherTierCardsStaked",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "impl", values?: undefined): string;
  encodeFunctionData(functionFragment: "isOwner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "lastUpdateState",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastUserClaim",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "lowerTierCardsStaked",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(functionFragment: "nft", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardSent",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setImplementation",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "stakingToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokensStaked",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "totalHigherTierCardsPerUser",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalLowerTierCardsPerUser",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalPoolSize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalReward",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalRewardPerSecond",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalStaked",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "unstakeFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "unstakeFeeDuration",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "userApy", values: [string]): string;
  encodeFunctionData(
    functionFragment: "userLastStakeTime",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "utils", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getUserCardsStaked",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "getPoolData", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getPoolData2",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateUsers",
    values: [string[]]
  ): string;
  encodeFunctionData(functionFragment: "update", values?: undefined): string;
  encodeFunctionData(functionFragment: "updateUser", values: [string]): string;
  encodeFunctionData(
    functionFragment: "init",
    values: [string, string, string, string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "stakeCards",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getApyByStake",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getApy",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getBoostedApy",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "getReward", values: [string]): string;
  encodeFunctionData(functionFragment: "getTotalApy", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getUserRewardPerSecond",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155BatchReceived",
    values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;

  decodeFunctionResult(functionFragment: "apyStruct", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "endRewardTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "feeReceiverAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBlockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "higherTierCardsStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "impl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isOwner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lastUpdateState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastUserClaim",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lowerTierCardsStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nft", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rewardSent", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rewardToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakingToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalHigherTierCardsPerUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalLowerTierCardsPerUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalPoolSize",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalRewardPerSecond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unstakeFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unstakeFeeDuration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "userApy", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "userLastStakeTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "utils", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getUserCardsStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolData2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateUsers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "update", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "updateUser", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "init", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stakeCards", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getApyByStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getApy", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getBoostedApy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getReward", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getTotalApy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserRewardPerSecond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155BatchReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;

  events: {
    "OwnershipTransferred(address,address)": EventFragment;
    "RewardClaimed(address,uint256,uint256)": EventFragment;
    "Staked(address,uint256[],uint256)": EventFragment;
    "Withdrawn(address,uint256[],uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RewardClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Staked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdrawn"): EventFragment;
}

export class NftStaking extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: NftStakingInterface;

  functions: {
    apyStruct(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      amount: BigNumber;
      apy: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    "apyStruct(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      amount: BigNumber;
      apy: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    endRewardTime(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "endRewardTime()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    feeReceiverAddress(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "feeReceiverAddress()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    getBlockNumber(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "getBlockNumber()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    higherTierCardsStaked(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "higherTierCardsStaked(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    impl(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "impl()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * Returns true if the caller is the current owner.
     */
    isOwner(
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * Returns true if the caller is the current owner.
     */
    "isOwner()"(
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    lastUpdateState(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "lastUpdateState()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    lastUserClaim(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "lastUserClaim(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    lowerTierCardsStaked(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "lowerTierCardsStaked(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    name(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "name()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    nft(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "nft()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * Returns the address of the current owner.
     */
    owner(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * Returns the address of the current owner.
     */
    "owner()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    "renounceOwnership()"(overrides?: Overrides): Promise<ContractTransaction>;

    rewardSent(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "rewardSent()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    rewardToken(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "rewardToken()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    setImplementation(
      _newImpl: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setImplementation(address)"(
      _newImpl: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    stakingToken(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "stakingToken()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    tokensStaked(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "tokensStaked(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    totalHigherTierCardsPerUser(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "totalHigherTierCardsPerUser()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    totalLowerTierCardsPerUser(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "totalLowerTierCardsPerUser()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    totalPoolSize(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "totalPoolSize()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    totalReward(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "totalReward()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    totalRewardPerSecond(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "totalRewardPerSecond()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    totalStaked(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "totalStaked()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    unstakeFee(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "unstakeFee()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    unstakeFeeDuration(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "unstakeFeeDuration()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    userApy(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "userApy(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    userLastStakeTime(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "userLastStakeTime(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    utils(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "utils()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    getUserCardsStaked(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber[];
      1: BigNumber[];
    }>;

    "getUserCardsStaked(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber[];
      1: BigNumber[];
    }>;

    getPoolData(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      _totalStaked: BigNumber;
      _poolSize: BigNumber;
      _remaining: BigNumber;
      _roiMin: BigNumber;
      _roiMax: BigNumber;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: BigNumber;
      4: BigNumber;
    }>;

    "getPoolData(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      _totalStaked: BigNumber;
      _poolSize: BigNumber;
      _remaining: BigNumber;
      _roiMin: BigNumber;
      _roiMax: BigNumber;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: BigNumber;
      4: BigNumber;
    }>;

    getPoolData2(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      _earnedReward: BigNumber;
      _roi: BigNumber;
      _roiBoost: BigNumber;
      _stakedNft: BigNumber;
      _userStakedTokens: BigNumber;
      _freeUnstakeTime: BigNumber;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: BigNumber;
      4: BigNumber;
      5: BigNumber;
    }>;

    "getPoolData2(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      _earnedReward: BigNumber;
      _roi: BigNumber;
      _roiBoost: BigNumber;
      _stakedNft: BigNumber;
      _userStakedTokens: BigNumber;
      _freeUnstakeTime: BigNumber;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: BigNumber;
      4: BigNumber;
      5: BigNumber;
    }>;

    updateUsers(
      _userAddresses: string[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "updateUsers(address[])"(
      _userAddresses: string[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    update(overrides?: Overrides): Promise<ContractTransaction>;

    "update()"(overrides?: Overrides): Promise<ContractTransaction>;

    updateUser(
      _userAddress: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "updateUser(address)"(
      _userAddress: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    init(
      _name: string,
      _feeReceiverAddress: string,
      _utilsAddress: string,
      _nft: string,
      _stakingToken: string,
      _rewardToken: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "init(string,address,address,address,address,address)"(
      _name: string,
      _feeReceiverAddress: string,
      _utilsAddress: string,
      _nft: string,
      _stakingToken: string,
      _rewardToken: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    stakeCards(
      _ids: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "stakeCards(uint256[])"(
      _ids: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    withdraw(
      _ids: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "withdraw(uint256[])"(
      _ids: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    getApyByStake(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "getApyByStake(uint256)"(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    getApy(
      _nfts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      apy: BigNumber;
      boostedApy: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    "getApy(uint256[])"(
      _nfts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      apy: BigNumber;
      boostedApy: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    getBoostedApy(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "getBoostedApy(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    getReward(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "getReward(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    getTotalApy(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "getTotalApy(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    getUserRewardPerSecond(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "getUserRewardPerSecond(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value MUST result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of a single ERC1155 token type
     * @param _amount The amount of tokens being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _id The id of the token being transferred
     * @param _operator The address which called the `safeTransferFrom` function
     */
    onERC1155Received(
      _operator: string,
      _from: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value MUST result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of a single ERC1155 token type
     * @param _amount The amount of tokens being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _id The id of the token being transferred
     * @param _operator The address which called the `safeTransferFrom` function
     */
    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      _operator: string,
      _from: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value WILL result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of multiple ERC1155 token types
     * @param _amounts An array containing amounts of each token being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _ids An array containing ids of each token being transferred
     * @param _operator The address which called the `safeBatchTransferFrom` function
     */
    onERC1155BatchReceived(
      _operator: string,
      _from: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value WILL result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of multiple ERC1155 token types
     * @param _amounts An array containing amounts of each token being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _ids An array containing ids of each token being transferred
     * @param _operator The address which called the `safeBatchTransferFrom` function
     */
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
      _operator: string,
      _from: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "supportsInterface(bytes4)"(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;
  };

  apyStruct(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<{
    amount: BigNumber;
    apy: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  "apyStruct(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<{
    amount: BigNumber;
    apy: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  endRewardTime(overrides?: CallOverrides): Promise<BigNumber>;

  "endRewardTime()"(overrides?: CallOverrides): Promise<BigNumber>;

  feeReceiverAddress(overrides?: CallOverrides): Promise<string>;

  "feeReceiverAddress()"(overrides?: CallOverrides): Promise<string>;

  getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

  "getBlockNumber()"(overrides?: CallOverrides): Promise<BigNumber>;

  higherTierCardsStaked(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "higherTierCardsStaked(address,uint256)"(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  impl(overrides?: CallOverrides): Promise<string>;

  "impl()"(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns true if the caller is the current owner.
   */
  isOwner(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns true if the caller is the current owner.
   */
  "isOwner()"(overrides?: CallOverrides): Promise<boolean>;

  lastUpdateState(overrides?: CallOverrides): Promise<BigNumber>;

  "lastUpdateState()"(overrides?: CallOverrides): Promise<BigNumber>;

  lastUserClaim(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  "lastUserClaim(address)"(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  lowerTierCardsStaked(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "lowerTierCardsStaked(address,uint256)"(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  name(overrides?: CallOverrides): Promise<string>;

  "name()"(overrides?: CallOverrides): Promise<string>;

  nft(overrides?: CallOverrides): Promise<string>;

  "nft()"(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  "owner()"(overrides?: CallOverrides): Promise<string>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  "renounceOwnership()"(overrides?: Overrides): Promise<ContractTransaction>;

  rewardSent(overrides?: CallOverrides): Promise<BigNumber>;

  "rewardSent()"(overrides?: CallOverrides): Promise<BigNumber>;

  rewardToken(overrides?: CallOverrides): Promise<string>;

  "rewardToken()"(overrides?: CallOverrides): Promise<string>;

  setImplementation(
    _newImpl: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setImplementation(address)"(
    _newImpl: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  stakingToken(overrides?: CallOverrides): Promise<string>;

  "stakingToken()"(overrides?: CallOverrides): Promise<string>;

  tokensStaked(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  "tokensStaked(address)"(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalHigherTierCardsPerUser(overrides?: CallOverrides): Promise<BigNumber>;

  "totalHigherTierCardsPerUser()"(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalLowerTierCardsPerUser(overrides?: CallOverrides): Promise<BigNumber>;

  "totalLowerTierCardsPerUser()"(overrides?: CallOverrides): Promise<BigNumber>;

  totalPoolSize(overrides?: CallOverrides): Promise<BigNumber>;

  "totalPoolSize()"(overrides?: CallOverrides): Promise<BigNumber>;

  totalReward(overrides?: CallOverrides): Promise<BigNumber>;

  "totalReward()"(overrides?: CallOverrides): Promise<BigNumber>;

  totalRewardPerSecond(overrides?: CallOverrides): Promise<BigNumber>;

  "totalRewardPerSecond()"(overrides?: CallOverrides): Promise<BigNumber>;

  totalStaked(overrides?: CallOverrides): Promise<BigNumber>;

  "totalStaked()"(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  "transferOwnership(address)"(
    newOwner: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  unstakeFee(overrides?: CallOverrides): Promise<BigNumber>;

  "unstakeFee()"(overrides?: CallOverrides): Promise<BigNumber>;

  unstakeFeeDuration(overrides?: CallOverrides): Promise<BigNumber>;

  "unstakeFeeDuration()"(overrides?: CallOverrides): Promise<BigNumber>;

  userApy(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  "userApy(address)"(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  userLastStakeTime(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "userLastStakeTime(address)"(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  utils(overrides?: CallOverrides): Promise<string>;

  "utils()"(overrides?: CallOverrides): Promise<string>;

  getUserCardsStaked(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<{
    0: BigNumber[];
    1: BigNumber[];
  }>;

  "getUserCardsStaked(address)"(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<{
    0: BigNumber[];
    1: BigNumber[];
  }>;

  getPoolData(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<{
    _totalStaked: BigNumber;
    _poolSize: BigNumber;
    _remaining: BigNumber;
    _roiMin: BigNumber;
    _roiMax: BigNumber;
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
    3: BigNumber;
    4: BigNumber;
  }>;

  "getPoolData(address)"(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<{
    _totalStaked: BigNumber;
    _poolSize: BigNumber;
    _remaining: BigNumber;
    _roiMin: BigNumber;
    _roiMax: BigNumber;
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
    3: BigNumber;
    4: BigNumber;
  }>;

  getPoolData2(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<{
    _earnedReward: BigNumber;
    _roi: BigNumber;
    _roiBoost: BigNumber;
    _stakedNft: BigNumber;
    _userStakedTokens: BigNumber;
    _freeUnstakeTime: BigNumber;
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
    3: BigNumber;
    4: BigNumber;
    5: BigNumber;
  }>;

  "getPoolData2(address)"(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<{
    _earnedReward: BigNumber;
    _roi: BigNumber;
    _roiBoost: BigNumber;
    _stakedNft: BigNumber;
    _userStakedTokens: BigNumber;
    _freeUnstakeTime: BigNumber;
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
    3: BigNumber;
    4: BigNumber;
    5: BigNumber;
  }>;

  updateUsers(
    _userAddresses: string[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "updateUsers(address[])"(
    _userAddresses: string[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  update(overrides?: Overrides): Promise<ContractTransaction>;

  "update()"(overrides?: Overrides): Promise<ContractTransaction>;

  updateUser(
    _userAddress: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "updateUser(address)"(
    _userAddress: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  init(
    _name: string,
    _feeReceiverAddress: string,
    _utilsAddress: string,
    _nft: string,
    _stakingToken: string,
    _rewardToken: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "init(string,address,address,address,address,address)"(
    _name: string,
    _feeReceiverAddress: string,
    _utilsAddress: string,
    _nft: string,
    _stakingToken: string,
    _rewardToken: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  stakeCards(
    _ids: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "stakeCards(uint256[])"(
    _ids: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  withdraw(
    _ids: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "withdraw(uint256[])"(
    _ids: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  getApyByStake(
    _amount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getApyByStake(uint256)"(
    _amount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getApy(
    _nfts: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<{
    apy: BigNumber;
    boostedApy: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  "getApy(uint256[])"(
    _nfts: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<{
    apy: BigNumber;
    boostedApy: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  getBoostedApy(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getBoostedApy(address)"(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getReward(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getReward(address)"(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getTotalApy(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getTotalApy(address)"(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getUserRewardPerSecond(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getUserRewardPerSecond(address)"(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value MUST result in the transaction being reverted Note: The token contract address is always the message sender
   * Handle the receipt of a single ERC1155 token type
   * @param _amount The amount of tokens being transferred
   * @param _data Additional data with no specified format
   * @param _from The address which previously owned the token
   * @param _id The id of the token being transferred
   * @param _operator The address which called the `safeTransferFrom` function
   */
  onERC1155Received(
    _operator: string,
    _from: string,
    _id: BigNumberish,
    _amount: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value MUST result in the transaction being reverted Note: The token contract address is always the message sender
   * Handle the receipt of a single ERC1155 token type
   * @param _amount The amount of tokens being transferred
   * @param _data Additional data with no specified format
   * @param _from The address which previously owned the token
   * @param _id The id of the token being transferred
   * @param _operator The address which called the `safeTransferFrom` function
   */
  "onERC1155Received(address,address,uint256,uint256,bytes)"(
    _operator: string,
    _from: string,
    _id: BigNumberish,
    _amount: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value WILL result in the transaction being reverted Note: The token contract address is always the message sender
   * Handle the receipt of multiple ERC1155 token types
   * @param _amounts An array containing amounts of each token being transferred
   * @param _data Additional data with no specified format
   * @param _from The address which previously owned the token
   * @param _ids An array containing ids of each token being transferred
   * @param _operator The address which called the `safeBatchTransferFrom` function
   */
  onERC1155BatchReceived(
    _operator: string,
    _from: string,
    _ids: BigNumberish[],
    _amounts: BigNumberish[],
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value WILL result in the transaction being reverted Note: The token contract address is always the message sender
   * Handle the receipt of multiple ERC1155 token types
   * @param _amounts An array containing amounts of each token being transferred
   * @param _data Additional data with no specified format
   * @param _from The address which previously owned the token
   * @param _ids An array containing ids of each token being transferred
   * @param _operator The address which called the `safeBatchTransferFrom` function
   */
  "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
    _operator: string,
    _from: string,
    _ids: BigNumberish[],
    _amounts: BigNumberish[],
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  supportsInterface(
    _interfaceID: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "supportsInterface(bytes4)"(
    _interfaceID: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    apyStruct(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      amount: BigNumber;
      apy: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    "apyStruct(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      amount: BigNumber;
      apy: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    endRewardTime(overrides?: CallOverrides): Promise<BigNumber>;

    "endRewardTime()"(overrides?: CallOverrides): Promise<BigNumber>;

    feeReceiverAddress(overrides?: CallOverrides): Promise<string>;

    "feeReceiverAddress()"(overrides?: CallOverrides): Promise<string>;

    getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    "getBlockNumber()"(overrides?: CallOverrides): Promise<BigNumber>;

    higherTierCardsStaked(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "higherTierCardsStaked(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    impl(overrides?: CallOverrides): Promise<string>;

    "impl()"(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns true if the caller is the current owner.
     */
    isOwner(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns true if the caller is the current owner.
     */
    "isOwner()"(overrides?: CallOverrides): Promise<boolean>;

    lastUpdateState(overrides?: CallOverrides): Promise<BigNumber>;

    "lastUpdateState()"(overrides?: CallOverrides): Promise<BigNumber>;

    lastUserClaim(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    "lastUserClaim(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lowerTierCardsStaked(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "lowerTierCardsStaked(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    "name()"(overrides?: CallOverrides): Promise<string>;

    nft(overrides?: CallOverrides): Promise<string>;

    "nft()"(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    "owner()"(overrides?: CallOverrides): Promise<string>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    "renounceOwnership()"(overrides?: CallOverrides): Promise<void>;

    rewardSent(overrides?: CallOverrides): Promise<BigNumber>;

    "rewardSent()"(overrides?: CallOverrides): Promise<BigNumber>;

    rewardToken(overrides?: CallOverrides): Promise<string>;

    "rewardToken()"(overrides?: CallOverrides): Promise<string>;

    setImplementation(
      _newImpl: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "setImplementation(address)"(
      _newImpl: string,
      overrides?: CallOverrides
    ): Promise<void>;

    stakingToken(overrides?: CallOverrides): Promise<string>;

    "stakingToken()"(overrides?: CallOverrides): Promise<string>;

    tokensStaked(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    "tokensStaked(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalHigherTierCardsPerUser(overrides?: CallOverrides): Promise<BigNumber>;

    "totalHigherTierCardsPerUser()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalLowerTierCardsPerUser(overrides?: CallOverrides): Promise<BigNumber>;

    "totalLowerTierCardsPerUser()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalPoolSize(overrides?: CallOverrides): Promise<BigNumber>;

    "totalPoolSize()"(overrides?: CallOverrides): Promise<BigNumber>;

    totalReward(overrides?: CallOverrides): Promise<BigNumber>;

    "totalReward()"(overrides?: CallOverrides): Promise<BigNumber>;

    totalRewardPerSecond(overrides?: CallOverrides): Promise<BigNumber>;

    "totalRewardPerSecond()"(overrides?: CallOverrides): Promise<BigNumber>;

    totalStaked(overrides?: CallOverrides): Promise<BigNumber>;

    "totalStaked()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    "transferOwnership(address)"(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    unstakeFee(overrides?: CallOverrides): Promise<BigNumber>;

    "unstakeFee()"(overrides?: CallOverrides): Promise<BigNumber>;

    unstakeFeeDuration(overrides?: CallOverrides): Promise<BigNumber>;

    "unstakeFeeDuration()"(overrides?: CallOverrides): Promise<BigNumber>;

    userApy(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    "userApy(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userLastStakeTime(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "userLastStakeTime(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    utils(overrides?: CallOverrides): Promise<string>;

    "utils()"(overrides?: CallOverrides): Promise<string>;

    getUserCardsStaked(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber[];
      1: BigNumber[];
    }>;

    "getUserCardsStaked(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber[];
      1: BigNumber[];
    }>;

    getPoolData(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      _totalStaked: BigNumber;
      _poolSize: BigNumber;
      _remaining: BigNumber;
      _roiMin: BigNumber;
      _roiMax: BigNumber;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: BigNumber;
      4: BigNumber;
    }>;

    "getPoolData(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      _totalStaked: BigNumber;
      _poolSize: BigNumber;
      _remaining: BigNumber;
      _roiMin: BigNumber;
      _roiMax: BigNumber;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: BigNumber;
      4: BigNumber;
    }>;

    getPoolData2(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      _earnedReward: BigNumber;
      _roi: BigNumber;
      _roiBoost: BigNumber;
      _stakedNft: BigNumber;
      _userStakedTokens: BigNumber;
      _freeUnstakeTime: BigNumber;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: BigNumber;
      4: BigNumber;
      5: BigNumber;
    }>;

    "getPoolData2(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      _earnedReward: BigNumber;
      _roi: BigNumber;
      _roiBoost: BigNumber;
      _stakedNft: BigNumber;
      _userStakedTokens: BigNumber;
      _freeUnstakeTime: BigNumber;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: BigNumber;
      4: BigNumber;
      5: BigNumber;
    }>;

    updateUsers(
      _userAddresses: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    "updateUsers(address[])"(
      _userAddresses: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    update(overrides?: CallOverrides): Promise<void>;

    "update()"(overrides?: CallOverrides): Promise<void>;

    updateUser(_userAddress: string, overrides?: CallOverrides): Promise<void>;

    "updateUser(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    init(
      _name: string,
      _feeReceiverAddress: string,
      _utilsAddress: string,
      _nft: string,
      _stakingToken: string,
      _rewardToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "init(string,address,address,address,address,address)"(
      _name: string,
      _feeReceiverAddress: string,
      _utilsAddress: string,
      _nft: string,
      _stakingToken: string,
      _rewardToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    stakeCards(_ids: BigNumberish[], overrides?: CallOverrides): Promise<void>;

    "stakeCards(uint256[])"(
      _ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(_ids: BigNumberish[], overrides?: CallOverrides): Promise<void>;

    "withdraw(uint256[])"(
      _ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    getApyByStake(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getApyByStake(uint256)"(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getApy(
      _nfts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      apy: BigNumber;
      boostedApy: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    "getApy(uint256[])"(
      _nfts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      apy: BigNumber;
      boostedApy: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    getBoostedApy(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getBoostedApy(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReward(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getReward(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalApy(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getTotalApy(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserRewardPerSecond(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getUserRewardPerSecond(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value MUST result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of a single ERC1155 token type
     * @param _amount The amount of tokens being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _id The id of the token being transferred
     * @param _operator The address which called the `safeTransferFrom` function
     */
    onERC1155Received(
      _operator: string,
      _from: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value MUST result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of a single ERC1155 token type
     * @param _amount The amount of tokens being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _id The id of the token being transferred
     * @param _operator The address which called the `safeTransferFrom` function
     */
    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      _operator: string,
      _from: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value WILL result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of multiple ERC1155 token types
     * @param _amounts An array containing amounts of each token being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _ids An array containing ids of each token being transferred
     * @param _operator The address which called the `safeBatchTransferFrom` function
     */
    onERC1155BatchReceived(
      _operator: string,
      _from: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value WILL result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of multiple ERC1155 token types
     * @param _amounts An array containing amounts of each token being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _ids An array containing ids of each token being transferred
     * @param _operator The address which called the `safeBatchTransferFrom` function
     */
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
      _operator: string,
      _from: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "supportsInterface(bytes4)"(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    OwnershipTransferred(
      previousOwner: string | null,
      newOwner: string | null
    ): EventFilter;

    RewardClaimed(
      userAddress: string | null,
      requiredRewardAmount: null,
      rewardAmount: null
    ): EventFilter;

    Staked(
      userAddress: string | null,
      ids: null,
      tokenAmount: null
    ): EventFilter;

    Withdrawn(
      userAddress: string | null,
      ids: null,
      tokenAmount: null,
      fee: null
    ): EventFilter;
  };

  estimateGas: {
    apyStruct(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "apyStruct(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    endRewardTime(overrides?: CallOverrides): Promise<BigNumber>;

    "endRewardTime()"(overrides?: CallOverrides): Promise<BigNumber>;

    feeReceiverAddress(overrides?: CallOverrides): Promise<BigNumber>;

    "feeReceiverAddress()"(overrides?: CallOverrides): Promise<BigNumber>;

    getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    "getBlockNumber()"(overrides?: CallOverrides): Promise<BigNumber>;

    higherTierCardsStaked(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "higherTierCardsStaked(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    impl(overrides?: CallOverrides): Promise<BigNumber>;

    "impl()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns true if the caller is the current owner.
     */
    isOwner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns true if the caller is the current owner.
     */
    "isOwner()"(overrides?: CallOverrides): Promise<BigNumber>;

    lastUpdateState(overrides?: CallOverrides): Promise<BigNumber>;

    "lastUpdateState()"(overrides?: CallOverrides): Promise<BigNumber>;

    lastUserClaim(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    "lastUserClaim(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lowerTierCardsStaked(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "lowerTierCardsStaked(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    "name()"(overrides?: CallOverrides): Promise<BigNumber>;

    nft(overrides?: CallOverrides): Promise<BigNumber>;

    "nft()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    "owner()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: Overrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    "renounceOwnership()"(overrides?: Overrides): Promise<BigNumber>;

    rewardSent(overrides?: CallOverrides): Promise<BigNumber>;

    "rewardSent()"(overrides?: CallOverrides): Promise<BigNumber>;

    rewardToken(overrides?: CallOverrides): Promise<BigNumber>;

    "rewardToken()"(overrides?: CallOverrides): Promise<BigNumber>;

    setImplementation(
      _newImpl: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "setImplementation(address)"(
      _newImpl: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    stakingToken(overrides?: CallOverrides): Promise<BigNumber>;

    "stakingToken()"(overrides?: CallOverrides): Promise<BigNumber>;

    tokensStaked(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    "tokensStaked(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalHigherTierCardsPerUser(overrides?: CallOverrides): Promise<BigNumber>;

    "totalHigherTierCardsPerUser()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalLowerTierCardsPerUser(overrides?: CallOverrides): Promise<BigNumber>;

    "totalLowerTierCardsPerUser()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalPoolSize(overrides?: CallOverrides): Promise<BigNumber>;

    "totalPoolSize()"(overrides?: CallOverrides): Promise<BigNumber>;

    totalReward(overrides?: CallOverrides): Promise<BigNumber>;

    "totalReward()"(overrides?: CallOverrides): Promise<BigNumber>;

    totalRewardPerSecond(overrides?: CallOverrides): Promise<BigNumber>;

    "totalRewardPerSecond()"(overrides?: CallOverrides): Promise<BigNumber>;

    totalStaked(overrides?: CallOverrides): Promise<BigNumber>;

    "totalStaked()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    unstakeFee(overrides?: CallOverrides): Promise<BigNumber>;

    "unstakeFee()"(overrides?: CallOverrides): Promise<BigNumber>;

    unstakeFeeDuration(overrides?: CallOverrides): Promise<BigNumber>;

    "unstakeFeeDuration()"(overrides?: CallOverrides): Promise<BigNumber>;

    userApy(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    "userApy(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userLastStakeTime(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "userLastStakeTime(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    utils(overrides?: CallOverrides): Promise<BigNumber>;

    "utils()"(overrides?: CallOverrides): Promise<BigNumber>;

    getUserCardsStaked(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getUserCardsStaked(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPoolData(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    "getPoolData(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPoolData2(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getPoolData2(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateUsers(
      _userAddresses: string[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "updateUsers(address[])"(
      _userAddresses: string[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    update(overrides?: Overrides): Promise<BigNumber>;

    "update()"(overrides?: Overrides): Promise<BigNumber>;

    updateUser(_userAddress: string, overrides?: Overrides): Promise<BigNumber>;

    "updateUser(address)"(
      _userAddress: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    init(
      _name: string,
      _feeReceiverAddress: string,
      _utilsAddress: string,
      _nft: string,
      _stakingToken: string,
      _rewardToken: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "init(string,address,address,address,address,address)"(
      _name: string,
      _feeReceiverAddress: string,
      _utilsAddress: string,
      _nft: string,
      _stakingToken: string,
      _rewardToken: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    stakeCards(_ids: BigNumberish[], overrides?: Overrides): Promise<BigNumber>;

    "stakeCards(uint256[])"(
      _ids: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    withdraw(_ids: BigNumberish[], overrides?: Overrides): Promise<BigNumber>;

    "withdraw(uint256[])"(
      _ids: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    getApyByStake(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getApyByStake(uint256)"(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getApy(
      _nfts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getApy(uint256[])"(
      _nfts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBoostedApy(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getBoostedApy(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReward(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getReward(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalApy(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getTotalApy(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserRewardPerSecond(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getUserRewardPerSecond(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value MUST result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of a single ERC1155 token type
     * @param _amount The amount of tokens being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _id The id of the token being transferred
     * @param _operator The address which called the `safeTransferFrom` function
     */
    onERC1155Received(
      _operator: string,
      _from: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value MUST result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of a single ERC1155 token type
     * @param _amount The amount of tokens being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _id The id of the token being transferred
     * @param _operator The address which called the `safeTransferFrom` function
     */
    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      _operator: string,
      _from: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value WILL result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of multiple ERC1155 token types
     * @param _amounts An array containing amounts of each token being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _ids An array containing ids of each token being transferred
     * @param _operator The address which called the `safeBatchTransferFrom` function
     */
    onERC1155BatchReceived(
      _operator: string,
      _from: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value WILL result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of multiple ERC1155 token types
     * @param _amounts An array containing amounts of each token being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _ids An array containing ids of each token being transferred
     * @param _operator The address which called the `safeBatchTransferFrom` function
     */
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
      _operator: string,
      _from: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "supportsInterface(bytes4)"(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    apyStruct(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "apyStruct(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    endRewardTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "endRewardTime()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    feeReceiverAddress(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "feeReceiverAddress()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBlockNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "getBlockNumber()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    higherTierCardsStaked(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "higherTierCardsStaked(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    impl(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "impl()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns true if the caller is the current owner.
     */
    isOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns true if the caller is the current owner.
     */
    "isOwner()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastUpdateState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "lastUpdateState()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastUserClaim(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "lastUserClaim(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lowerTierCardsStaked(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "lowerTierCardsStaked(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "name()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nft(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "nft()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    "owner()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: Overrides): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    "renounceOwnership()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    rewardSent(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "rewardSent()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "rewardToken()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setImplementation(
      _newImpl: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setImplementation(address)"(
      _newImpl: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "stakingToken()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokensStaked(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "tokensStaked(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalHigherTierCardsPerUser(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "totalHigherTierCardsPerUser()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalLowerTierCardsPerUser(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "totalLowerTierCardsPerUser()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalPoolSize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "totalPoolSize()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalReward(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "totalReward()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalRewardPerSecond(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "totalRewardPerSecond()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalStaked(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "totalStaked()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    unstakeFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "unstakeFee()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    unstakeFeeDuration(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "unstakeFeeDuration()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userApy(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "userApy(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userLastStakeTime(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "userLastStakeTime(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    utils(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "utils()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getUserCardsStaked(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getUserCardsStaked(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPoolData(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getPoolData(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPoolData2(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getPoolData2(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    updateUsers(
      _userAddresses: string[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "updateUsers(address[])"(
      _userAddresses: string[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    update(overrides?: Overrides): Promise<PopulatedTransaction>;

    "update()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    updateUser(
      _userAddress: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "updateUser(address)"(
      _userAddress: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    init(
      _name: string,
      _feeReceiverAddress: string,
      _utilsAddress: string,
      _nft: string,
      _stakingToken: string,
      _rewardToken: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "init(string,address,address,address,address,address)"(
      _name: string,
      _feeReceiverAddress: string,
      _utilsAddress: string,
      _nft: string,
      _stakingToken: string,
      _rewardToken: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    stakeCards(
      _ids: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "stakeCards(uint256[])"(
      _ids: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    withdraw(
      _ids: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "withdraw(uint256[])"(
      _ids: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    getApyByStake(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getApyByStake(uint256)"(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getApy(
      _nfts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getApy(uint256[])"(
      _nfts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBoostedApy(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getBoostedApy(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getReward(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getReward(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalApy(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getTotalApy(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserRewardPerSecond(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getUserRewardPerSecond(address)"(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value MUST result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of a single ERC1155 token type
     * @param _amount The amount of tokens being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _id The id of the token being transferred
     * @param _operator The address which called the `safeTransferFrom` function
     */
    onERC1155Received(
      _operator: string,
      _from: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value MUST result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of a single ERC1155 token type
     * @param _amount The amount of tokens being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _id The id of the token being transferred
     * @param _operator The address which called the `safeTransferFrom` function
     */
    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      _operator: string,
      _from: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value WILL result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of multiple ERC1155 token types
     * @param _amounts An array containing amounts of each token being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _ids An array containing ids of each token being transferred
     * @param _operator The address which called the `safeBatchTransferFrom` function
     */
    onERC1155BatchReceived(
      _operator: string,
      _from: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated This function MAY throw to revert and reject the transfer Return of other amount than the magic value WILL result in the transaction being reverted Note: The token contract address is always the message sender
     * Handle the receipt of multiple ERC1155 token types
     * @param _amounts An array containing amounts of each token being transferred
     * @param _data Additional data with no specified format
     * @param _from The address which previously owned the token
     * @param _ids An array containing ids of each token being transferred
     * @param _operator The address which called the `safeBatchTransferFrom` function
     */
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
      _operator: string,
      _from: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "supportsInterface(bytes4)"(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
