/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  CallOverrides
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface Erc1155TradableInterface extends ethers.utils.Interface {
  functions: {
    "addMinter(address)": FunctionFragment;
    "addWhitelistAdmin(address)": FunctionFragment;
    "balanceOf(address,uint256)": FunctionFragment;
    "balanceOfBatch(address[],uint256[])": FunctionFragment;
    "creators(uint256)": FunctionFragment;
    "isMinter(address)": FunctionFragment;
    "isOwner()": FunctionFragment;
    "isWhitelistAdmin(address)": FunctionFragment;
    "name()": FunctionFragment;
    "owner()": FunctionFragment;
    "renounceMinter()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "renounceWhitelistAdmin()": FunctionFragment;
    "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "safeTransferFrom(address,address,uint256,uint256,bytes)": FunctionFragment;
    "setApprovalForAll(address,bool)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "symbol()": FunctionFragment;
    "tokenMaxSupply(uint256)": FunctionFragment;
    "tokenSupply(uint256)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "removeWhitelistAdmin(address)": FunctionFragment;
    "removeMinter(address)": FunctionFragment;
    "uri(uint256)": FunctionFragment;
    "totalSupply(uint256)": FunctionFragment;
    "maxSupply(uint256)": FunctionFragment;
    "setBaseMetadataURI(string)": FunctionFragment;
    "create(uint256,uint256,string,bytes)": FunctionFragment;
    "mint(address,uint256,uint256,bytes)": FunctionFragment;
    "isApprovedForAll(address,address)": FunctionFragment;
  };

  encodeFunctionData(functionFragment: "addMinter", values: [string]): string;
  encodeFunctionData(
    functionFragment: "addWhitelistAdmin",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOfBatch",
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "creators",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "isMinter", values: [string]): string;
  encodeFunctionData(functionFragment: "isOwner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "isWhitelistAdmin",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "renounceMinter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceWhitelistAdmin",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "safeBatchTransferFrom",
    values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom",
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "tokenMaxSupply",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenSupply",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeWhitelistAdmin",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMinter",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "uri", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "maxSupply",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setBaseMetadataURI",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "create",
    values: [BigNumberish, BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [string, string]
  ): string;

  decodeFunctionResult(functionFragment: "addMinter", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "addWhitelistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "balanceOfBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "creators", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isMinter", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isOwner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isWhitelistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceMinter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceWhitelistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeBatchTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokenMaxSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeWhitelistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMinter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "uri", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "maxSupply", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setBaseMetadataURI",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;

  events: {
    "ApprovalForAll(address,address,bool)": EventFragment;
    "MinterAdded(address)": EventFragment;
    "MinterRemoved(address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "TransferBatch(address,address,address,uint256[],uint256[])": EventFragment;
    "TransferSingle(address,address,address,uint256,uint256)": EventFragment;
    "URI(string,uint256)": EventFragment;
    "WhitelistAdminAdded(address)": EventFragment;
    "WhitelistAdminRemoved(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ApprovalForAll"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MinterAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MinterRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferBatch"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferSingle"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "URI"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WhitelistAdminAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WhitelistAdminRemoved"): EventFragment;
}

export class Erc1155Tradable extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: Erc1155TradableInterface;

  functions: {
    addMinter(
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addMinter(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addWhitelistAdmin(
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addWhitelistAdmin(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Get the balance of an account's Tokens
     * @param _id ID of the Token
     * @param _owner The address of the token holder
     */
    balanceOf(
      _owner: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Get the balance of an account's Tokens
     * @param _id ID of the Token
     * @param _owner The address of the token holder
     */
    "balanceOf(address,uint256)"(
      _owner: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Get the balance of multiple account/token pairs
     * @param _ids ID of the Tokens
     * @param _owners The addresses of the token holders
     */
    balanceOfBatch(
      _owners: string[],
      _ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber[];
    }>;

    /**
     * Get the balance of multiple account/token pairs
     * @param _ids ID of the Tokens
     * @param _owners The addresses of the token holders
     */
    "balanceOfBatch(address[],uint256[])"(
      _owners: string[],
      _ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber[];
    }>;

    creators(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "creators(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    isMinter(
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isMinter(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * Returns true if the caller is the current owner.
     */
    isOwner(
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * Returns true if the caller is the current owner.
     */
    "isOwner()"(
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    isWhitelistAdmin(
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isWhitelistAdmin(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    name(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "name()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * Returns the address of the current owner.
     */
    owner(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * Returns the address of the current owner.
     */
    "owner()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    renounceMinter(overrides?: Overrides): Promise<ContractTransaction>;

    "renounceMinter()"(overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    "renounceOwnership()"(overrides?: Overrides): Promise<ContractTransaction>;

    renounceWhitelistAdmin(overrides?: Overrides): Promise<ContractTransaction>;

    "renounceWhitelistAdmin()"(
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Send multiple types of Tokens from the _from address to the _to address (with safety call)
     * @param _amounts Transfer amounts per token type
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source addresses
     * @param _ids IDs of each token type
     * @param _to Target addresses
     */
    safeBatchTransferFrom(
      _from: string,
      _to: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Send multiple types of Tokens from the _from address to the _to address (with safety call)
     * @param _amounts Transfer amounts per token type
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source addresses
     * @param _ids IDs of each token type
     * @param _to Target addresses
     */
    "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"(
      _from: string,
      _to: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Transfers amount amount of an _id from the _from address to the _to address specified
     * @param _amount Transfered amount
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source address
     * @param _id ID of the token type
     * @param _to Target address
     */
    safeTransferFrom(
      _from: string,
      _to: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Transfers amount amount of an _id from the _from address to the _to address specified
     * @param _amount Transfered amount
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source address
     * @param _id ID of the token type
     * @param _to Target address
     */
    "safeTransferFrom(address,address,uint256,uint256,bytes)"(
      _from: string,
      _to: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Enable or disable approval for a third party ("operator") to manage all of caller's tokens
     * @param _approved True if the operator is approved, false to revoke approval
     * @param _operator Address to add to the set of authorized operators
     */
    setApprovalForAll(
      _operator: string,
      _approved: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Enable or disable approval for a third party ("operator") to manage all of caller's tokens
     * @param _approved True if the operator is approved, false to revoke approval
     * @param _operator Address to add to the set of authorized operators
     */
    "setApprovalForAll(address,bool)"(
      _operator: string,
      _approved: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    "supportsInterface(bytes4)"(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    symbol(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "symbol()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    tokenMaxSupply(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "tokenMaxSupply(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    tokenSupply(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "tokenSupply(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    removeWhitelistAdmin(
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removeWhitelistAdmin(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    removeMinter(
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removeMinter(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * URIs are defined in RFC 3986.      URIs are assumed to be deterministically generated based on token ID      Token IDs are assumed to be represented in their hex format in URIs
     * A distinct Uniform Resource Identifier (URI) for a given token.
     */
    uri(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * URIs are defined in RFC 3986.      URIs are assumed to be deterministically generated based on token ID      Token IDs are assumed to be represented in their hex format in URIs
     * A distinct Uniform Resource Identifier (URI) for a given token.
     */
    "uri(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * Returns the total quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    totalSupply(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Returns the total quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    "totalSupply(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Returns the max quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    maxSupply(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Returns the max quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    "maxSupply(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Will update the base URL of token's URI
     * @param _newBaseMetadataURI New base URL of token's URI
     */
    setBaseMetadataURI(
      _newBaseMetadataURI: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Will update the base URL of token's URI
     * @param _newBaseMetadataURI New base URL of token's URI
     */
    "setBaseMetadataURI(string)"(
      _newBaseMetadataURI: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Creates a new token type and assigns _initialSupply to an address
     * @param _data Optional data to pass if receiver is contract
     * @param _initialSupply Optional amount to supply the first owner
     * @param _maxSupply max supply allowed
     * @param _uri Optional URI for this token type
     */
    create(
      _maxSupply: BigNumberish,
      _initialSupply: BigNumberish,
      _uri: string,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Creates a new token type and assigns _initialSupply to an address
     * @param _data Optional data to pass if receiver is contract
     * @param _initialSupply Optional amount to supply the first owner
     * @param _maxSupply max supply allowed
     * @param _uri Optional URI for this token type
     */
    "create(uint256,uint256,string,bytes)"(
      _maxSupply: BigNumberish,
      _initialSupply: BigNumberish,
      _uri: string,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Mints some amount of tokens to an address
     * @param _data Data to pass if receiver is contract
     * @param _id Token ID to mint
     * @param _quantity Amount of tokens to mint
     * @param _to Address of the future owner of the token
     */
    mint(
      _to: string,
      _id: BigNumberish,
      _quantity: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Mints some amount of tokens to an address
     * @param _data Data to pass if receiver is contract
     * @param _id Token ID to mint
     * @param _quantity Amount of tokens to mint
     * @param _to Address of the future owner of the token
     */
    "mint(address,uint256,uint256,bytes)"(
      _to: string,
      _id: BigNumberish,
      _quantity: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
     */
    isApprovedForAll(
      _owner: string,
      _operator: string,
      overrides?: CallOverrides
    ): Promise<{
      isOperator: boolean;
      0: boolean;
    }>;

    /**
     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
     */
    "isApprovedForAll(address,address)"(
      _owner: string,
      _operator: string,
      overrides?: CallOverrides
    ): Promise<{
      isOperator: boolean;
      0: boolean;
    }>;
  };

  addMinter(
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addMinter(address)"(
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addWhitelistAdmin(
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addWhitelistAdmin(address)"(
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Get the balance of an account's Tokens
   * @param _id ID of the Token
   * @param _owner The address of the token holder
   */
  balanceOf(
    _owner: string,
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get the balance of an account's Tokens
   * @param _id ID of the Token
   * @param _owner The address of the token holder
   */
  "balanceOf(address,uint256)"(
    _owner: string,
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get the balance of multiple account/token pairs
   * @param _ids ID of the Tokens
   * @param _owners The addresses of the token holders
   */
  balanceOfBatch(
    _owners: string[],
    _ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Get the balance of multiple account/token pairs
   * @param _ids ID of the Tokens
   * @param _owners The addresses of the token holders
   */
  "balanceOfBatch(address[],uint256[])"(
    _owners: string[],
    _ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  creators(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  "creators(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  isMinter(account: string, overrides?: CallOverrides): Promise<boolean>;

  "isMinter(address)"(
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns true if the caller is the current owner.
   */
  isOwner(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns true if the caller is the current owner.
   */
  "isOwner()"(overrides?: CallOverrides): Promise<boolean>;

  isWhitelistAdmin(
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isWhitelistAdmin(address)"(
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  name(overrides?: CallOverrides): Promise<string>;

  "name()"(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  "owner()"(overrides?: CallOverrides): Promise<string>;

  renounceMinter(overrides?: Overrides): Promise<ContractTransaction>;

  "renounceMinter()"(overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  "renounceOwnership()"(overrides?: Overrides): Promise<ContractTransaction>;

  renounceWhitelistAdmin(overrides?: Overrides): Promise<ContractTransaction>;

  "renounceWhitelistAdmin()"(
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Send multiple types of Tokens from the _from address to the _to address (with safety call)
   * @param _amounts Transfer amounts per token type
   * @param _data Additional data with no specified format, sent in call to `_to`
   * @param _from Source addresses
   * @param _ids IDs of each token type
   * @param _to Target addresses
   */
  safeBatchTransferFrom(
    _from: string,
    _to: string,
    _ids: BigNumberish[],
    _amounts: BigNumberish[],
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Send multiple types of Tokens from the _from address to the _to address (with safety call)
   * @param _amounts Transfer amounts per token type
   * @param _data Additional data with no specified format, sent in call to `_to`
   * @param _from Source addresses
   * @param _ids IDs of each token type
   * @param _to Target addresses
   */
  "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"(
    _from: string,
    _to: string,
    _ids: BigNumberish[],
    _amounts: BigNumberish[],
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Transfers amount amount of an _id from the _from address to the _to address specified
   * @param _amount Transfered amount
   * @param _data Additional data with no specified format, sent in call to `_to`
   * @param _from Source address
   * @param _id ID of the token type
   * @param _to Target address
   */
  safeTransferFrom(
    _from: string,
    _to: string,
    _id: BigNumberish,
    _amount: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Transfers amount amount of an _id from the _from address to the _to address specified
   * @param _amount Transfered amount
   * @param _data Additional data with no specified format, sent in call to `_to`
   * @param _from Source address
   * @param _id ID of the token type
   * @param _to Target address
   */
  "safeTransferFrom(address,address,uint256,uint256,bytes)"(
    _from: string,
    _to: string,
    _id: BigNumberish,
    _amount: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Enable or disable approval for a third party ("operator") to manage all of caller's tokens
   * @param _approved True if the operator is approved, false to revoke approval
   * @param _operator Address to add to the set of authorized operators
   */
  setApprovalForAll(
    _operator: string,
    _approved: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Enable or disable approval for a third party ("operator") to manage all of caller's tokens
   * @param _approved True if the operator is approved, false to revoke approval
   * @param _operator Address to add to the set of authorized operators
   */
  "setApprovalForAll(address,bool)"(
    _operator: string,
    _approved: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Query if a contract implements an interface
   * @param _interfaceID The interface identifier, as specified in ERC-165
   */
  supportsInterface(
    _interfaceID: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Query if a contract implements an interface
   * @param _interfaceID The interface identifier, as specified in ERC-165
   */
  "supportsInterface(bytes4)"(
    _interfaceID: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  symbol(overrides?: CallOverrides): Promise<string>;

  "symbol()"(overrides?: CallOverrides): Promise<string>;

  tokenMaxSupply(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "tokenMaxSupply(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  tokenSupply(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "tokenSupply(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  "transferOwnership(address)"(
    newOwner: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  removeWhitelistAdmin(
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removeWhitelistAdmin(address)"(
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  removeMinter(
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removeMinter(address)"(
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * URIs are defined in RFC 3986.      URIs are assumed to be deterministically generated based on token ID      Token IDs are assumed to be represented in their hex format in URIs
   * A distinct Uniform Resource Identifier (URI) for a given token.
   */
  uri(_id: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * URIs are defined in RFC 3986.      URIs are assumed to be deterministically generated based on token ID      Token IDs are assumed to be represented in their hex format in URIs
   * A distinct Uniform Resource Identifier (URI) for a given token.
   */
  "uri(uint256)"(_id: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the total quantity for a token ID
   * @param _id uint256 ID of the token to query
   */
  totalSupply(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns the total quantity for a token ID
   * @param _id uint256 ID of the token to query
   */
  "totalSupply(uint256)"(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the max quantity for a token ID
   * @param _id uint256 ID of the token to query
   */
  maxSupply(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns the max quantity for a token ID
   * @param _id uint256 ID of the token to query
   */
  "maxSupply(uint256)"(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Will update the base URL of token's URI
   * @param _newBaseMetadataURI New base URL of token's URI
   */
  setBaseMetadataURI(
    _newBaseMetadataURI: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Will update the base URL of token's URI
   * @param _newBaseMetadataURI New base URL of token's URI
   */
  "setBaseMetadataURI(string)"(
    _newBaseMetadataURI: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Creates a new token type and assigns _initialSupply to an address
   * @param _data Optional data to pass if receiver is contract
   * @param _initialSupply Optional amount to supply the first owner
   * @param _maxSupply max supply allowed
   * @param _uri Optional URI for this token type
   */
  create(
    _maxSupply: BigNumberish,
    _initialSupply: BigNumberish,
    _uri: string,
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Creates a new token type and assigns _initialSupply to an address
   * @param _data Optional data to pass if receiver is contract
   * @param _initialSupply Optional amount to supply the first owner
   * @param _maxSupply max supply allowed
   * @param _uri Optional URI for this token type
   */
  "create(uint256,uint256,string,bytes)"(
    _maxSupply: BigNumberish,
    _initialSupply: BigNumberish,
    _uri: string,
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Mints some amount of tokens to an address
   * @param _data Data to pass if receiver is contract
   * @param _id Token ID to mint
   * @param _quantity Amount of tokens to mint
   * @param _to Address of the future owner of the token
   */
  mint(
    _to: string,
    _id: BigNumberish,
    _quantity: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Mints some amount of tokens to an address
   * @param _data Data to pass if receiver is contract
   * @param _id Token ID to mint
   * @param _quantity Amount of tokens to mint
   * @param _to Address of the future owner of the token
   */
  "mint(address,uint256,uint256,bytes)"(
    _to: string,
    _id: BigNumberish,
    _quantity: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
   */
  isApprovedForAll(
    _owner: string,
    _operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
   */
  "isApprovedForAll(address,address)"(
    _owner: string,
    _operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    addMinter(account: string, overrides?: CallOverrides): Promise<void>;

    "addMinter(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addWhitelistAdmin(
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "addWhitelistAdmin(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the balance of an account's Tokens
     * @param _id ID of the Token
     * @param _owner The address of the token holder
     */
    balanceOf(
      _owner: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the balance of an account's Tokens
     * @param _id ID of the Token
     * @param _owner The address of the token holder
     */
    "balanceOf(address,uint256)"(
      _owner: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the balance of multiple account/token pairs
     * @param _ids ID of the Tokens
     * @param _owners The addresses of the token holders
     */
    balanceOfBatch(
      _owners: string[],
      _ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Get the balance of multiple account/token pairs
     * @param _ids ID of the Tokens
     * @param _owners The addresses of the token holders
     */
    "balanceOfBatch(address[],uint256[])"(
      _owners: string[],
      _ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    creators(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    "creators(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    isMinter(account: string, overrides?: CallOverrides): Promise<boolean>;

    "isMinter(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns true if the caller is the current owner.
     */
    isOwner(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns true if the caller is the current owner.
     */
    "isOwner()"(overrides?: CallOverrides): Promise<boolean>;

    isWhitelistAdmin(
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isWhitelistAdmin(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    name(overrides?: CallOverrides): Promise<string>;

    "name()"(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    "owner()"(overrides?: CallOverrides): Promise<string>;

    renounceMinter(overrides?: CallOverrides): Promise<void>;

    "renounceMinter()"(overrides?: CallOverrides): Promise<void>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    "renounceOwnership()"(overrides?: CallOverrides): Promise<void>;

    renounceWhitelistAdmin(overrides?: CallOverrides): Promise<void>;

    "renounceWhitelistAdmin()"(overrides?: CallOverrides): Promise<void>;

    /**
     * Send multiple types of Tokens from the _from address to the _to address (with safety call)
     * @param _amounts Transfer amounts per token type
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source addresses
     * @param _ids IDs of each token type
     * @param _to Target addresses
     */
    safeBatchTransferFrom(
      _from: string,
      _to: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Send multiple types of Tokens from the _from address to the _to address (with safety call)
     * @param _amounts Transfer amounts per token type
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source addresses
     * @param _ids IDs of each token type
     * @param _to Target addresses
     */
    "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"(
      _from: string,
      _to: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Transfers amount amount of an _id from the _from address to the _to address specified
     * @param _amount Transfered amount
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source address
     * @param _id ID of the token type
     * @param _to Target address
     */
    safeTransferFrom(
      _from: string,
      _to: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Transfers amount amount of an _id from the _from address to the _to address specified
     * @param _amount Transfered amount
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source address
     * @param _id ID of the token type
     * @param _to Target address
     */
    "safeTransferFrom(address,address,uint256,uint256,bytes)"(
      _from: string,
      _to: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Enable or disable approval for a third party ("operator") to manage all of caller's tokens
     * @param _approved True if the operator is approved, false to revoke approval
     * @param _operator Address to add to the set of authorized operators
     */
    setApprovalForAll(
      _operator: string,
      _approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Enable or disable approval for a third party ("operator") to manage all of caller's tokens
     * @param _approved True if the operator is approved, false to revoke approval
     * @param _operator Address to add to the set of authorized operators
     */
    "setApprovalForAll(address,bool)"(
      _operator: string,
      _approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    "supportsInterface(bytes4)"(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    symbol(overrides?: CallOverrides): Promise<string>;

    "symbol()"(overrides?: CallOverrides): Promise<string>;

    tokenMaxSupply(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "tokenMaxSupply(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenSupply(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "tokenSupply(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    "transferOwnership(address)"(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeWhitelistAdmin(
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "removeWhitelistAdmin(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeMinter(account: string, overrides?: CallOverrides): Promise<void>;

    "removeMinter(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * URIs are defined in RFC 3986.      URIs are assumed to be deterministically generated based on token ID      Token IDs are assumed to be represented in their hex format in URIs
     * A distinct Uniform Resource Identifier (URI) for a given token.
     */
    uri(_id: BigNumberish, overrides?: CallOverrides): Promise<string>;

    /**
     * URIs are defined in RFC 3986.      URIs are assumed to be deterministically generated based on token ID      Token IDs are assumed to be represented in their hex format in URIs
     * A distinct Uniform Resource Identifier (URI) for a given token.
     */
    "uri(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns the total quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    totalSupply(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the total quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    "totalSupply(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the max quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    maxSupply(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the max quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    "maxSupply(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Will update the base URL of token's URI
     * @param _newBaseMetadataURI New base URL of token's URI
     */
    setBaseMetadataURI(
      _newBaseMetadataURI: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Will update the base URL of token's URI
     * @param _newBaseMetadataURI New base URL of token's URI
     */
    "setBaseMetadataURI(string)"(
      _newBaseMetadataURI: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Creates a new token type and assigns _initialSupply to an address
     * @param _data Optional data to pass if receiver is contract
     * @param _initialSupply Optional amount to supply the first owner
     * @param _maxSupply max supply allowed
     * @param _uri Optional URI for this token type
     */
    create(
      _maxSupply: BigNumberish,
      _initialSupply: BigNumberish,
      _uri: string,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Creates a new token type and assigns _initialSupply to an address
     * @param _data Optional data to pass if receiver is contract
     * @param _initialSupply Optional amount to supply the first owner
     * @param _maxSupply max supply allowed
     * @param _uri Optional URI for this token type
     */
    "create(uint256,uint256,string,bytes)"(
      _maxSupply: BigNumberish,
      _initialSupply: BigNumberish,
      _uri: string,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mints some amount of tokens to an address
     * @param _data Data to pass if receiver is contract
     * @param _id Token ID to mint
     * @param _quantity Amount of tokens to mint
     * @param _to Address of the future owner of the token
     */
    mint(
      _to: string,
      _id: BigNumberish,
      _quantity: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Mints some amount of tokens to an address
     * @param _data Data to pass if receiver is contract
     * @param _id Token ID to mint
     * @param _quantity Amount of tokens to mint
     * @param _to Address of the future owner of the token
     */
    "mint(address,uint256,uint256,bytes)"(
      _to: string,
      _id: BigNumberish,
      _quantity: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
     */
    isApprovedForAll(
      _owner: string,
      _operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
     */
    "isApprovedForAll(address,address)"(
      _owner: string,
      _operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    ApprovalForAll(
      _owner: string | null,
      _operator: string | null,
      _approved: null
    ): EventFilter;

    MinterAdded(account: string | null): EventFilter;

    MinterRemoved(account: string | null): EventFilter;

    OwnershipTransferred(
      previousOwner: string | null,
      newOwner: string | null
    ): EventFilter;

    TransferBatch(
      _operator: string | null,
      _from: string | null,
      _to: string | null,
      _ids: null,
      _amounts: null
    ): EventFilter;

    TransferSingle(
      _operator: string | null,
      _from: string | null,
      _to: string | null,
      _id: null,
      _amount: null
    ): EventFilter;

    URI(_uri: null, _id: BigNumberish | null): EventFilter;

    WhitelistAdminAdded(account: string | null): EventFilter;

    WhitelistAdminRemoved(account: string | null): EventFilter;
  };

  estimateGas: {
    addMinter(account: string, overrides?: Overrides): Promise<BigNumber>;

    "addMinter(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addWhitelistAdmin(
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addWhitelistAdmin(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Get the balance of an account's Tokens
     * @param _id ID of the Token
     * @param _owner The address of the token holder
     */
    balanceOf(
      _owner: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the balance of an account's Tokens
     * @param _id ID of the Token
     * @param _owner The address of the token holder
     */
    "balanceOf(address,uint256)"(
      _owner: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the balance of multiple account/token pairs
     * @param _ids ID of the Tokens
     * @param _owners The addresses of the token holders
     */
    balanceOfBatch(
      _owners: string[],
      _ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the balance of multiple account/token pairs
     * @param _ids ID of the Tokens
     * @param _owners The addresses of the token holders
     */
    "balanceOfBatch(address[],uint256[])"(
      _owners: string[],
      _ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    creators(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    "creators(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isMinter(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    "isMinter(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns true if the caller is the current owner.
     */
    isOwner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns true if the caller is the current owner.
     */
    "isOwner()"(overrides?: CallOverrides): Promise<BigNumber>;

    isWhitelistAdmin(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isWhitelistAdmin(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    "name()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    "owner()"(overrides?: CallOverrides): Promise<BigNumber>;

    renounceMinter(overrides?: Overrides): Promise<BigNumber>;

    "renounceMinter()"(overrides?: Overrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: Overrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    "renounceOwnership()"(overrides?: Overrides): Promise<BigNumber>;

    renounceWhitelistAdmin(overrides?: Overrides): Promise<BigNumber>;

    "renounceWhitelistAdmin()"(overrides?: Overrides): Promise<BigNumber>;

    /**
     * Send multiple types of Tokens from the _from address to the _to address (with safety call)
     * @param _amounts Transfer amounts per token type
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source addresses
     * @param _ids IDs of each token type
     * @param _to Target addresses
     */
    safeBatchTransferFrom(
      _from: string,
      _to: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Send multiple types of Tokens from the _from address to the _to address (with safety call)
     * @param _amounts Transfer amounts per token type
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source addresses
     * @param _ids IDs of each token type
     * @param _to Target addresses
     */
    "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"(
      _from: string,
      _to: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Transfers amount amount of an _id from the _from address to the _to address specified
     * @param _amount Transfered amount
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source address
     * @param _id ID of the token type
     * @param _to Target address
     */
    safeTransferFrom(
      _from: string,
      _to: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Transfers amount amount of an _id from the _from address to the _to address specified
     * @param _amount Transfered amount
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source address
     * @param _id ID of the token type
     * @param _to Target address
     */
    "safeTransferFrom(address,address,uint256,uint256,bytes)"(
      _from: string,
      _to: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Enable or disable approval for a third party ("operator") to manage all of caller's tokens
     * @param _approved True if the operator is approved, false to revoke approval
     * @param _operator Address to add to the set of authorized operators
     */
    setApprovalForAll(
      _operator: string,
      _approved: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Enable or disable approval for a third party ("operator") to manage all of caller's tokens
     * @param _approved True if the operator is approved, false to revoke approval
     * @param _operator Address to add to the set of authorized operators
     */
    "setApprovalForAll(address,bool)"(
      _operator: string,
      _approved: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    "supportsInterface(bytes4)"(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    "symbol()"(overrides?: CallOverrides): Promise<BigNumber>;

    tokenMaxSupply(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "tokenMaxSupply(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenSupply(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "tokenSupply(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    removeWhitelistAdmin(
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "removeWhitelistAdmin(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    removeMinter(account: string, overrides?: Overrides): Promise<BigNumber>;

    "removeMinter(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * URIs are defined in RFC 3986.      URIs are assumed to be deterministically generated based on token ID      Token IDs are assumed to be represented in their hex format in URIs
     * A distinct Uniform Resource Identifier (URI) for a given token.
     */
    uri(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * URIs are defined in RFC 3986.      URIs are assumed to be deterministically generated based on token ID      Token IDs are assumed to be represented in their hex format in URIs
     * A distinct Uniform Resource Identifier (URI) for a given token.
     */
    "uri(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the total quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    totalSupply(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the total quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    "totalSupply(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the max quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    maxSupply(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the max quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    "maxSupply(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Will update the base URL of token's URI
     * @param _newBaseMetadataURI New base URL of token's URI
     */
    setBaseMetadataURI(
      _newBaseMetadataURI: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Will update the base URL of token's URI
     * @param _newBaseMetadataURI New base URL of token's URI
     */
    "setBaseMetadataURI(string)"(
      _newBaseMetadataURI: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Creates a new token type and assigns _initialSupply to an address
     * @param _data Optional data to pass if receiver is contract
     * @param _initialSupply Optional amount to supply the first owner
     * @param _maxSupply max supply allowed
     * @param _uri Optional URI for this token type
     */
    create(
      _maxSupply: BigNumberish,
      _initialSupply: BigNumberish,
      _uri: string,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Creates a new token type and assigns _initialSupply to an address
     * @param _data Optional data to pass if receiver is contract
     * @param _initialSupply Optional amount to supply the first owner
     * @param _maxSupply max supply allowed
     * @param _uri Optional URI for this token type
     */
    "create(uint256,uint256,string,bytes)"(
      _maxSupply: BigNumberish,
      _initialSupply: BigNumberish,
      _uri: string,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Mints some amount of tokens to an address
     * @param _data Data to pass if receiver is contract
     * @param _id Token ID to mint
     * @param _quantity Amount of tokens to mint
     * @param _to Address of the future owner of the token
     */
    mint(
      _to: string,
      _id: BigNumberish,
      _quantity: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Mints some amount of tokens to an address
     * @param _data Data to pass if receiver is contract
     * @param _id Token ID to mint
     * @param _quantity Amount of tokens to mint
     * @param _to Address of the future owner of the token
     */
    "mint(address,uint256,uint256,bytes)"(
      _to: string,
      _id: BigNumberish,
      _quantity: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
     */
    isApprovedForAll(
      _owner: string,
      _operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
     */
    "isApprovedForAll(address,address)"(
      _owner: string,
      _operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addMinter(
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addMinter(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addWhitelistAdmin(
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addWhitelistAdmin(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the balance of an account's Tokens
     * @param _id ID of the Token
     * @param _owner The address of the token holder
     */
    balanceOf(
      _owner: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the balance of an account's Tokens
     * @param _id ID of the Token
     * @param _owner The address of the token holder
     */
    "balanceOf(address,uint256)"(
      _owner: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the balance of multiple account/token pairs
     * @param _ids ID of the Tokens
     * @param _owners The addresses of the token holders
     */
    balanceOfBatch(
      _owners: string[],
      _ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the balance of multiple account/token pairs
     * @param _ids ID of the Tokens
     * @param _owners The addresses of the token holders
     */
    "balanceOfBatch(address[],uint256[])"(
      _owners: string[],
      _ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    creators(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "creators(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isMinter(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isMinter(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if the caller is the current owner.
     */
    isOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns true if the caller is the current owner.
     */
    "isOwner()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isWhitelistAdmin(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isWhitelistAdmin(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "name()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    "owner()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceMinter(overrides?: Overrides): Promise<PopulatedTransaction>;

    "renounceMinter()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: Overrides): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    "renounceOwnership()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    renounceWhitelistAdmin(
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "renounceWhitelistAdmin()"(
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Send multiple types of Tokens from the _from address to the _to address (with safety call)
     * @param _amounts Transfer amounts per token type
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source addresses
     * @param _ids IDs of each token type
     * @param _to Target addresses
     */
    safeBatchTransferFrom(
      _from: string,
      _to: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Send multiple types of Tokens from the _from address to the _to address (with safety call)
     * @param _amounts Transfer amounts per token type
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source addresses
     * @param _ids IDs of each token type
     * @param _to Target addresses
     */
    "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"(
      _from: string,
      _to: string,
      _ids: BigNumberish[],
      _amounts: BigNumberish[],
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers amount amount of an _id from the _from address to the _to address specified
     * @param _amount Transfered amount
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source address
     * @param _id ID of the token type
     * @param _to Target address
     */
    safeTransferFrom(
      _from: string,
      _to: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers amount amount of an _id from the _from address to the _to address specified
     * @param _amount Transfered amount
     * @param _data Additional data with no specified format, sent in call to `_to`
     * @param _from Source address
     * @param _id ID of the token type
     * @param _to Target address
     */
    "safeTransferFrom(address,address,uint256,uint256,bytes)"(
      _from: string,
      _to: string,
      _id: BigNumberish,
      _amount: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Enable or disable approval for a third party ("operator") to manage all of caller's tokens
     * @param _approved True if the operator is approved, false to revoke approval
     * @param _operator Address to add to the set of authorized operators
     */
    setApprovalForAll(
      _operator: string,
      _approved: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Enable or disable approval for a third party ("operator") to manage all of caller's tokens
     * @param _approved True if the operator is approved, false to revoke approval
     * @param _operator Address to add to the set of authorized operators
     */
    "setApprovalForAll(address,bool)"(
      _operator: string,
      _approved: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    "supportsInterface(bytes4)"(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "symbol()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenMaxSupply(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "tokenMaxSupply(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenSupply(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "tokenSupply(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    removeWhitelistAdmin(
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removeWhitelistAdmin(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    removeMinter(
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removeMinter(address)"(
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * URIs are defined in RFC 3986.      URIs are assumed to be deterministically generated based on token ID      Token IDs are assumed to be represented in their hex format in URIs
     * A distinct Uniform Resource Identifier (URI) for a given token.
     */
    uri(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * URIs are defined in RFC 3986.      URIs are assumed to be deterministically generated based on token ID      Token IDs are assumed to be represented in their hex format in URIs
     * A distinct Uniform Resource Identifier (URI) for a given token.
     */
    "uri(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the total quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    totalSupply(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the total quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    "totalSupply(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the max quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    maxSupply(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the max quantity for a token ID
     * @param _id uint256 ID of the token to query
     */
    "maxSupply(uint256)"(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Will update the base URL of token's URI
     * @param _newBaseMetadataURI New base URL of token's URI
     */
    setBaseMetadataURI(
      _newBaseMetadataURI: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Will update the base URL of token's URI
     * @param _newBaseMetadataURI New base URL of token's URI
     */
    "setBaseMetadataURI(string)"(
      _newBaseMetadataURI: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a new token type and assigns _initialSupply to an address
     * @param _data Optional data to pass if receiver is contract
     * @param _initialSupply Optional amount to supply the first owner
     * @param _maxSupply max supply allowed
     * @param _uri Optional URI for this token type
     */
    create(
      _maxSupply: BigNumberish,
      _initialSupply: BigNumberish,
      _uri: string,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a new token type and assigns _initialSupply to an address
     * @param _data Optional data to pass if receiver is contract
     * @param _initialSupply Optional amount to supply the first owner
     * @param _maxSupply max supply allowed
     * @param _uri Optional URI for this token type
     */
    "create(uint256,uint256,string,bytes)"(
      _maxSupply: BigNumberish,
      _initialSupply: BigNumberish,
      _uri: string,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Mints some amount of tokens to an address
     * @param _data Data to pass if receiver is contract
     * @param _id Token ID to mint
     * @param _quantity Amount of tokens to mint
     * @param _to Address of the future owner of the token
     */
    mint(
      _to: string,
      _id: BigNumberish,
      _quantity: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Mints some amount of tokens to an address
     * @param _data Data to pass if receiver is contract
     * @param _id Token ID to mint
     * @param _quantity Amount of tokens to mint
     * @param _to Address of the future owner of the token
     */
    "mint(address,uint256,uint256,bytes)"(
      _to: string,
      _id: BigNumberish,
      _quantity: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
     */
    isApprovedForAll(
      _owner: string,
      _operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
     */
    "isApprovedForAll(address,address)"(
      _owner: string,
      _operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
